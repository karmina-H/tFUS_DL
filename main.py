import numpy as np

# .npy 파일 읽기
arr_in = np.load("input.npy")

# input.npy
print(type(arr_in))   # <class 'numpy.ndarray'>
print(arr_in.shape)   # (1125, 6) - 초음파기계 위치(3) + 초음파기계의 방향벡터(3)
print(arr_in.dtype)   # float64

# output.npy
arr_out = np.load("output.npy")
print(type(arr_out))   # <class 'numpy.ndarray'>
print(arr_out.shape)   # (1125, 101, 101, 101) -> 전체 ct영상을 101*101*101 크기로 만들어줌(패치화) 그래서 거기서 각 초음파의 value가
                       # 들어있는 것
print(arr_out.dtype)   # float64

'''
input의 위치벡터는 정규화 됨. (방향벡터는 정규화 일부로 안한듯..?)
output파일에 있는 데이터는 음수가 없음.
대부분의 데이터가 0이고 특정 값만높음(초음파가 도달하는곳만), output데이터 정규화 안한듯(아마 대부분 0이라 못한 걸 수도..)
그래서 이거 output data를 정규화 하고 안하고도 나중에 비교해보기
'''

# 결과가 경계박스가 아니라, 실제 이미지로 맵핑되는것
# 결과가 경계박스처럼 4점으로 맵핑되는 것
# 결과가 가장 센 중앙점 하나로만 맵핑되는 것
# 교수님께서 원하는 거는 중앙점 하나가 반대로 초음파기계로 맵핑되는것.

# 근데 이거 사람마다 학습하는 함수가 다를텐데, 입력으로 ct영상하고 초음파기계 위치하고 같이 주어져야 하는거 아닌가 고민 -> 뭔가 기존에는 ct영상
# 없이 했지만,영상이 있으면 Guidline을 제시하는 거니까 더 정확하지 않을까
# 특히 여러장의 ct영상과 여러장의 ct영상에서 나온 여러장의 데이터로 학습시키면 generalize가능할 것 이라고 생각함.

# 또 지금 100*100*100단위로 패치를 짤라서 사용하고 있는디, 이거 네트워크 두개 사용해서 하나는 위치와 방향에 따라서 대강 위치 때려맞추고
# 경계박스 생성하는거 하나하고, 그리고 만들어진 경계박스를 패치단위로 짜르지 말고 raw로 해서 정확하게 맞추는 것도 좋다고 생각함.(아니면
# 아주 작은 예를들어 5*5*5로 자른다던가)
